Here I will lay out the topics in this book to be discussed in order.

We will first begin with a fundemental question of what we are trying to do?
This book is written on the premise that you know something about computers and have written code in a language before - but I won't assume any more than that.
In my opinion the best way to learn about computers is to use them at a high level e.g. create a game in python or a website in HTML: build something cool and develop an interest in the subject, and then we start from the bottom and work our way up. It is essential to work from the bottom. My school's CS course had a strigma of being "from the 90's" especially for the first two years, but there was a good reason for this. Computing is built on patterns and patterns. Knowing them at a low level gives you an intuition at a higher level, and then for a level above that.

Another essential thing I want to teach is the idea of "good enough". I used to think computers were these magic things that were completely optimal and mathematically perfect. Yes, smart people work on and design these things, but when's the last time your computer crashed? The truth is that computers are not built to last forever. There are very few "forever-proof" things in programming because even the silicon itself is not perfect but good enough. That said, there is a way to do things well which is what the people who design our computers and software and networks have arrived at, and I want to teach you how they arrived at this and how you might do the same.

We will first begin with a fundemental question of what we are trying to do? Compute things? Why? How can we do that? Why use electricity and not wind or mirrors?

We will then talk about what the result of this thought process is - a computer. Or more specifcally, a CPU. This is the first time we will form an abstraction. Instead of manipulating 1's and 0's we will create general rules called instructions to do this.

At a certain complexity of application these instructions will become just as unwieldy as they were at a lower level in machine code. There are commonon ways we use these instructions, so we can abstract again to form rules for rules in our first "real" language, C.

At this point we have unlocked a whole new world of things to explore. 

OS
Concurrency
Virtualisation

Graphics 
2D 
3D

Networking 

Cybersecurity

Cryptography

Databases

Machine Learning

Even higher level languages.
Now you should see a pattern, C is too unwieldy for a certain even bigger level of program, so we can simplify C and its common use cases into a new language, Python!

Libraries